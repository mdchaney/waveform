waveform

Copyright 2014 Michael Chaney Consulting Corporation, all rights reserved

Released under the terms of the MIT or GPLv2 license.

This is a simple C program that will create a "wave form" of an AIFF or
WAVE file.  It is optimized for speed in probably the best way possible
on a modern CPU architecture: minimum of branching inside of loops.
That means that I have entire chunks of code copied verbatim except for
a few different lines of code to handle the dirty work of computing the
numbers.

The program is called like this:

waveform [--mean|--peak|--rms] [--mono] [--points x] [--scale y] [filename]

The program will output a set of integers (number specified by "points
parameter, default of 1000), one or two on each line (comma
separated for two numbers) that vary from "0" to "scale" (defaults to
"255").  The numbers represent the result of a set of sample points run
through an algorithm.

Let's say we have a WAVE file that is 3 minutes long at CD quality of
44100 samples per second.  There are 7,938,000 samples in the file.  At
1000 points there would be 7938 samples interpolated for each output
point.

1. "mean", "peak", and "rms" are three interpolation algorithms.  Choose
one, default is rms.

2. --mono will cause a 2 channel file to output only a single integer
per line representing an interpolation of both channels.

3. --points tells how many numbers to output

4. --scale will determine the scale of the output integers.  Note that
it is inclusive, so a scale of "255" will possibly include output
integers from "0" to "255" inclusive.

5. waveform accepts either a filename on the command line or it'll read
stdin.  It can be used as a pipe filter.

NOTE

As of right now this will only work on 2-channel 16-bit sample files.
It is fairly trivial to copy/modify the code to handle 1-channel and
8-bit files.  There are 6 file handling routines now - all three
algorithms (peak, rms, and mean) in two sets, one set for
same endianness and one for different endianness.  Those need to be
copied three more times to handle "8-bit mono", "16-bit mono", and
"8-bit stereo".  It would also be possible to add 24-bit, 32-bit, and
more than two channels.  As you can see the code would grow quickly and
at some point it might make sense to create the routines via macros.

It would be possible to simplify the code dramatically and have one main
processing loop.  However, such code would have a lot of branches inside
the main loop which would slow it down, although I haven't played with
it to see what impact it would have.  My goal on this project is raw
speed at the expense of everything else - I don't mind if I have code
that is replicated save for a few minor differences.

I have a Ruby version of this which outputs an actual PNG and takes
around 3 minutes to compute a wave form.  This program outputs the same
information in a text format and takes around 5/100ths of a second for
my files.  The text format is more useful for me as I can easily
create the PNG from that if I want, with that taking no more than
another fraction of a second.  Ruby totally rocks, just not for this
sort of heavy computation.
